<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B-series, trees, and Runge-Kutta — Daniel Worrall</title>
    <meta name="description"
        content="The rooted trees from Faà di Bruno's formula reappear as the accuracy conditions of Runge-Kutta ODE solvers. B-series make this connection precise.">
    <link rel="stylesheet" href="/style.css">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <!-- MathJax -->
    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$']], displayMath: [['$$', '$$'], ['\\[', '\\]']], processEscapes: true, tags: 'ams' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>
</head>

<body>

    <canvas id="neural-canvas"></canvas>

    <nav class="nav" role="navigation">
        <div class="nav__inner">
            <a href="/" class="nav__logo">d<span>.</span>worrall</a>
            <ul class="nav__links" id="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="/blog/">Blog</a></li>
                <li><a href="/publications.html">Publications</a></li>
                <li><a href="/talks.html">Talks</a></li>
                <li><a href="/teaching.html">Teaching</a></li>
            </ul>
            <div style="display:flex;align-items:center;gap:0.5rem;">
                <button class="nav__theme-toggle" id="theme-toggle" aria-label="Toggle dark/light mode">☀️</button>
                <button class="nav__hamburger" id="hamburger" aria-label="Toggle menu">
                    <span></span><span></span><span></span>
                </button>
            </div>
        </div>
    </nav>

    <main class="page-content">
        <div class="container">

            <article class="blog-post reveal">
                <header class="blog-post__header">
                    <p class="section-header__label">Writing</p>
                    <h1 class="blog-post__title">B-series, trees, and Runge-Kutta</h1>
                    <div class="blog-post__meta">
                        <time>February 2026 &middot; DRAFT</time>
                        <div class="blog-card__tags">
                            <span class="blog-card__tag">numerical methods</span>
                            <span class="blog-card__tag">rooted trees</span>
                        </div>
                    </div>
                </header>

                <div class="blog-post__content">

                    <h2>Rooted trees and ODEs</h2>

                    <p><strong>TL;DR</strong>: The
                        <a href="/blog/2023/11/rooted-trees-and-differentiation/">rooted trees</a> that
                        index higher-order derivatives also index the <em>accuracy conditions</em> of
                        numerical ODE solvers. A Runge-Kutta method is order-$p$ accurate exactly
                        when its weights match the correct tree coefficients for all trees up to
                        size $p$. B-series make this precise.
                    </p>

                    <p>In the <a href="/blog/2021/08/dual-numbers/">dual numbers</a> and
                        <a href="/blog/2026/02/hyper-dual-numbers/">hyper-dual numbers</a> posts we saw
                        that rooted trees appear naturally when you differentiate composed functions.
                        It turns out the same trees show up in a completely different corner of
                        mathematics: the numerical solution of differential equations. This post
                        explores that connection.
                    </p>

                    <h3>What is a differential equation?</h3>

                    <p>Suppose you know how fast something is changing, and you want to know
                        where it ends up. You have a rule $f$ that tells you the rate of change
                        at any position $y$:</p>

                    $$
                    y'(t) = f(y(t)).
                    $$

                    <p>Given a starting value $y(0) = y_0$, you want to find $y(t)$ for
                        all future times. This is an <em>ordinary differential equation</em> (ODE).</p>

                    <p>A simple example: if the rate of change equals the current value,
                        $y' = y$, then $y(t) = y_0 \, e^t$. But for most choices of $f$
                        there is no closed-form solution. We need a numerical method, meaning
                        we pick a step size $h$ and compute approximate values
                        $y_0, y_1, y_2, \ldots$ at times $0, h, 2h, \ldots$.</p>


                    <h2>Euler's method</h2>

                    <p>The simplest idea: use the current rate of change to step forward.</p>

                    $$
                    y_{n+1} = y_n + h\,f(y_n).
                    $$

                    <p>In words: "wherever you are, walk in the direction $f$ tells you, for
                        $h$ seconds." Here it is in Python:</p>

                    <pre><code class="language-python">def euler(f, y0, h, n_steps):
    y = y0
    ys = [y]
    for _ in range(n_steps):
        y = y + h * f(y)       # one Euler step
        ys.append(y)
    return ys</code></pre>

                    <p>Let's test it on $y' = y$ with $y_0 = 1$ and step size $h = 0.5$.
                        The exact solution is $e^t$:</p>

                    <pre><code class="language-python">import numpy as np

f = lambda y: y               # y' = y
ys = euler(f, 1.0, 0.5, 6)    # 6 steps of size 0.5

ts = np.arange(0, 3.5, 0.5)
exact = np.exp(ts)

for t, approx, ex in zip(ts, ys, exact):
    print(f"t={t:.1f}  euler={approx:.4f}  exact={ex:.4f}  error={abs(approx-ex):.4f}")
# t=0.0  euler=1.0000  exact=1.0000  error=0.0000
# t=0.5  euler=1.5000  exact=1.6487  error=0.1487
# t=1.0  euler=2.2500  exact=2.7183  error=0.4683
# t=1.5  euler=3.3750  exact=4.4817  error=1.1067
# t=2.0  euler=5.0625  exact=7.3891  error=2.3266
# t=2.5  euler=7.5938  exact=12.1825 error=4.5887
# t=3.0  euler=11.3906 exact=20.0855 error=8.6949</code></pre>

                    <p>Euler quickly drifts. By $t = 3$ the error is almost 9. Making $h$
                        smaller helps, but slowly: halving $h$ roughly halves the error.
                        We say Euler's method is <em>first-order accurate</em>: the error
                        per step is $O(h^2)$, so the accumulated error over a fixed time
                        interval is $O(h)$.</p>


                    <h2>Can we do better?</h2>

                    <p>Euler uses a single evaluation of $f$ at the start of the interval. What if
                        we evaluated $f$ at a few intermediate points and took a smarter average?
                        This is the idea behind <em>Runge-Kutta methods</em>.</p>

                    <p>The most famous one, "RK4," uses four evaluations per step:</p>

                    <pre><code class="language-python">def rk4(f, y0, h, n_steps):
    y = y0
    ys = [y]
    for _ in range(n_steps):
        k1 = f(y)
        k2 = f(y + h/2 * k1)      # midpoint using k1
        k3 = f(y + h/2 * k2)      # midpoint using k2
        k4 = f(y + h * k3)        # endpoint using k3
        y = y + h/6 * (k1 + 2*k2 + 2*k3 + k4)
        ys.append(y)
    return ys</code></pre>

                    <p>The recipe looks arbitrary: why those specific fractions
                        ($\tfrac{1}{2}$, $\tfrac{1}{2}$, $1$) and weights
                        ($\tfrac{1}{6}$, $\tfrac{1}{3}$, $\tfrac{1}{3}$, $\tfrac{1}{6}$)?
                        Let's first see that it works, then explain where the numbers come from.</p>

                    <pre><code class="language-python">ys_rk4 = rk4(f, 1.0, 0.5, 6)

for t, approx, ex in zip(ts, ys_rk4, exact):
    print(f"t={t:.1f}  rk4={approx:.6f}  exact={ex:.6f}  error={abs(approx-ex):.6f}")
# t=0.0  rk4=1.000000  exact=1.000000  error=0.000000
# t=0.5  rk4=1.648438  exact=1.648721  error=0.000284
# t=1.0  rk4=2.717347  exact=2.718282  error=0.000935
# t=1.5  rk4=4.479156  exact=4.481689  error=0.002533
# t=2.0  rk4=7.383846  exact=7.389056  error=0.005210
# t=2.5  rk4=12.172449 exact=12.182494 error=0.010045
# t=3.0  rk4=20.067033 exact=20.085537 error=0.018504</code></pre>

                    <p>At $t = 3$ the error is 0.02, compared to Euler's 8.7.
                        RK4 is <em>fourth-order accurate</em>: halving $h$ reduces the error
                        by a factor of $2^4 = 16$. Much better.</p>

                    <p>But how were those magic coefficients chosen? Kutta (1901) didn't
                        pull them out of thin air. He Taylor-expanded both sides and matched
                        the terms. This is the <em>order conditions</em> problem.</p>


                    <h2>The order conditions problem</h2>

                    <p>We want our numerical method to agree with the true solution as closely
                        as possible. "Agree" here means: if we Taylor-expand both
                        $y(t + h)$ (the exact answer) and $y_1$ (the numerical answer)
                        in powers of $h$, the coefficients should match up to some order $p$.</p>


                    <h3>The exact side: where the trees come from</h3>

                    <p>Taylor-expanding the exact solution around $t$:</p>

                    $$
                    y(t + h) = y + h\,y' + \frac{h^2}{2}\,y'' + \frac{h^3}{6}\,y''' + \cdots
                    $$

                    <p>Since $y' = f(y)$, the higher derivatives involve derivatives of $f$.
                        Let's compute them one by one and watch the tree structure emerge.</p>

                    <p><strong>First derivative.</strong> Our starting point: $y' = f$. There is one
                        term, and it corresponds to a single node $\bullet$.</p>

                    <p><strong>Second derivative.</strong> We differentiate $y' = f(y)$ with respect to $t$,
                        applying the chain rule:</p>

                    $$
                    y'' = \frac{d}{dt}f(y) = f'(y)\,y' = f'\,f.
                    $$

                    <p>One term. It has the structure "differentiate $f$ once and feed $f$ into it."
                        As a tree: $\bullet$ attached below $\bullet$, i.e. a chain of length 2.
                        We write this $[\bullet]$.</p>

                    <p><strong>Third derivative.</strong> Now differentiate $y'' = f'f$ using the product rule.
                        Each factor can be the one that gets differentiated:</p>

                    $$
                    y''' = \frac{d}{dt}(f'\,f) = \underbrace{f''\,(f,\, f)}_{\text{differentiate }f'} +
                    \underbrace{f'\,f'\,f}_{\text{differentiate }f}.
                    $$

                    <p>Two terms, two trees. The first, $f''(f,f)$, has the structure "differentiate $f$
                        twice and feed two copies of $f$ in." As a tree: two $\bullet$'s attached
                        below a root. We write $[\bullet,\bullet]$. The second, $f'f'f$, has
                        the structure "differentiate $f$, feed in ($f'$ fed by $f$)." As a tree:
                        a chain of length 3, $[[\bullet]]$.</p>

                    <p>The pattern continues. Each time we differentiate, the product rule splits
                        each existing term into multiple new terms. Each new term corresponds to a
                        way of <em>growing the tree by one vertex</em>. Here are all the terms
                        through order 4:</p>

                    <table style="margin: 1.5rem auto; border-collapse: collapse; font-size: 0.88rem;">
                        <thead>
                            <tr>
                                <th
                                    style="padding: 0.5rem 0.8rem; border-bottom: 2px solid var(--border-color); text-align: center;">
                                    $n$</th>
                                <th
                                    style="padding: 0.5rem 0.8rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Tree $\tau$</th>
                                <th
                                    style="padding: 0.5rem 0.8rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Elementary differential $F(\tau)$</th>
                                <th
                                    style="padding: 0.5rem 0.8rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td
                                    style="padding: 0.5rem 0.8rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    1</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $\tau_1 = \bullet$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">$f$
                                </td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">just
                                    $f$ itself</td>
                            </tr>
                            <tr>
                                <td
                                    style="padding: 0.5rem 0.8rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    2</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $\tau_2 = [\bullet]$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $f'\,f$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">root
                                    with one child</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem 0.8rem; text-align: center; border-bottom: 1px solid var(--border-color);"
                                    rowspan="2">3</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $\tau_3 = [\bullet, \bullet]$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $f''(f,f)$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">root
                                    with two children (bushy)</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $\tau_4 = [[\bullet]]$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $f'\,f'\,f$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">chain
                                    of 3 (tall)</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem 0.8rem; text-align: center; border-bottom: 1px solid var(--border-color);"
                                    rowspan="4">4</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $[\bullet,\bullet,\bullet]$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $f'''(f,f,f)$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">root
                                    with three children</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $[[\bullet],\bullet]$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $f''(f'f,\,f)$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">two
                                    children: one is a chain</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $[[\bullet,\bullet]]$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $f'\,f''(f,f)$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">one
                                    child which is bushy</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $[[[\bullet]]]$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">
                                    $f'\,f'\,f'\,f$</td>
                                <td style="padding: 0.5rem 0.8rem; border-bottom: 1px solid var(--border-color);">chain
                                    of 4</td>
                            </tr>
                        </tbody>
                    </table>

                    <p>The rule for reading a tree as a formula is recursive: a tree $[\tau_1, \ldots, \tau_m]$
                        (root with children $\tau_1, \ldots, \tau_m$) corresponds to
                        $f^{(m)}(F(\tau_1), \ldots, F(\tau_m))$. The $m$ children tell you how many times
                        to differentiate $f$ at the root, and each subtree tells you what to feed in.</p>

                    <p>Putting it together, the exact Taylor expansion is:</p>

                    $$
                    y(t+h) = y + \sum_{\tau} \frac{h^{|\tau|}}{\sigma(\tau)}\,\frac{1}{\gamma(\tau)}\,F(\tau)(y),
                    $$

                    <p>where $|\tau|$ is the number of vertices, $\sigma(\tau)$ is a symmetry factor
                        (accounting for repeated children), and $\gamma(\tau)$ is the <em>density</em> of
                        the tree (which comes from the factorials in the Taylor coefficients). For instance:</p>

                    $$
                    y(t+h) = y + h\,f + \frac{h^2}{2}\,f'f + \frac{h^3}{6}\,f''(f,f) + \frac{h^3}{6}\,f'f'f + \cdots
                    $$

                    <p>One term per tree.</p>


                    <h3>The numerical side: a worked example</h3>

                    <p>Now let's see how the <em>same</em> trees appear when we Taylor-expand a
                        Runge-Kutta method. We will work through a simple 2-stage method in full
                        detail.</p>

                    <p>Consider a general 2-stage explicit method with tableau:</p>

                    $$
                    \begin{array}{c|cc}
                    0 & \\
                    c_2 & a_{21} \\
                    \hline
                    & b_1 & b_2
                    \end{array}
                    $$

                    <p>The two stages are:</p>

                    $$\begin{aligned}
                    k_1 &= f(y), \\
                    k_2 &= f(y + h\,a_{21}\,k_1) = f(y + h\,a_{21}\,f(y)).
                    \end{aligned}$$

                    <p>The output is $y_1 = y + h(b_1 k_1 + b_2 k_2)$. We want to expand
                        $y_1$ in powers of $h$ and match against the exact expansion.</p>

                    <p><strong>Expanding $k_2$.</strong> Taylor-expand $f$ around $y$, writing $\delta = h\,a_{21}\,f$:
                    </p>

                    $$\begin{aligned}
                    k_2 &= f(y + \delta) \\
                    &= f + f'\,\delta + \tfrac{1}{2}f''\,\delta^2 + \cdots \\
                    &= f + h\,a_{21}\,f'\,f + \tfrac{h^2}{2}\,a_{21}^2\,f''(f,f) + O(h^3).
                    \end{aligned}$$

                    <p><strong>Assembling $y_1$.</strong> Plug $k_1 = f$ and the expanded $k_2$ into
                        $y_1 = y + h(b_1 k_1 + b_2 k_2)$:</p>

                    $$\begin{aligned}
                    y_1 &= y + h\,(b_1 + b_2)\,f \\
                    &\quad + h^2\,b_2\,a_{21}\,f'\,f \\
                    &\quad + \tfrac{h^3}{2}\,b_2\,a_{21}^2\,f''(f,f) \\
                    &\quad + O(h^4).
                    \end{aligned}$$

                    <p><strong>Matching.</strong> Compare this to the exact expansion term by term:</p>

                    <table style="margin: 1.5rem auto; border-collapse: collapse; font-size: 0.86rem;">
                        <thead>
                            <tr>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: center;">
                                    $h^n$</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Tree</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Exact</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    RK</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Condition</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td
                                    style="padding: 0.4rem 0.7rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    $h^1$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\bullet \to f$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$1$
                                </td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$b_1 +
                                    b_2$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$b_1 +
                                    b_2 = 1$</td>
                            </tr>
                            <tr>
                                <td
                                    style="padding: 0.4rem 0.7rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    $h^2$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $[\bullet] \to f'f$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\tfrac{1}{2}$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $b_2\,a_{21}$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $b_2\,a_{21} = \tfrac{1}{2}$</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.4rem 0.7rem; text-align: center; border-bottom: 1px solid var(--border-color);"
                                    rowspan="2">$h^3$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $[\bullet,\bullet] \to f''(f,f)$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\tfrac{1}{3}$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\tfrac{1}{2}b_2 a_{21}^2$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$b_2
                                    a_{21}^2 = \tfrac{2}{3}$</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $[[\bullet]] \to f'f'f$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\tfrac{1}{6}$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$0$
                                </td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$0
                                    \neq \tfrac{1}{6}$ &#10007;</td>
                            </tr>
                        </tbody>
                    </table>

                    <p>The two order-1 and order-2 conditions can be satisfied (e.g. $b_1 = b_2 = \tfrac{1}{2}$
                        and $a_{21} = 1$ gives the trapezoidal rule).
                        But at order 3, the tree $[[\bullet]]$ (the "tall" tree, $f'f'f$) requires a
                        term that a 2-stage method simply cannot produce.</p>

                    <p>Why? The term $f'f'f$ requires evaluating $f$, then feeding the result into $f'$,
                        then feeding <em>that</em> into another $f'$. Three levels of nesting. But with only
                        two stages, the deepest nesting we can achieve is: $k_1 = f(y)$, then
                        $k_2 = f(y + \alpha\, k_1)$. The Taylor expansion of $k_2$ generates terms like
                        $f'f$ (one level of nesting) and $f''(f,f)$ (one level, two arguments), but not
                        $f'(f'(f))$, because that would require a <em>third</em> stage
                        $k_3 = f(y + \beta\,k_2)$ to get a second level of nesting.</p>

                    <p>This is the essential insight: <strong>each tree represents a distinct pattern of
                            nested function evaluations</strong>. A method with $s$ stages can only produce trees
                        whose nesting depth is at most $s$. More stages allow deeper trees, giving
                        access to more order conditions and hence higher-order accuracy.</p>


                    <h3>The general Butcher tableau</h3>

                    <p>The same analysis works for any number of stages. A general
                        <em>$s$-stage Runge-Kutta method</em> is specified by
                        numbers $(a_{ij}, b_i, c_i)$ packed into a <em>Butcher tableau</em>:
                    </p>

                    $$
                    \begin{array}{c|c}
                    \mathbf{c} & A \\
                    \hline
                    & \mathbf{b}^T
                    \end{array}
                    \qquad\text{i.e.}\qquad
                    \begin{array}{c|cccc}
                    c_1 & a_{11} & a_{12} & \cdots & a_{1s} \\
                    c_2 & a_{21} & a_{22} & \cdots & a_{2s} \\
                    \vdots & \vdots & & \ddots & \vdots \\
                    c_s & a_{s1} & a_{s2} & \cdots & a_{ss} \\
                    \hline
                    & b_1 & b_2 & \cdots & b_s
                    \end{array}
                    $$

                    <p>The method computes $s$ intermediate slopes $k_i$, then combines them:</p>

                    $$\begin{aligned}
                    k_i &= f\!\left(y + h \sum_{j=1}^{s} a_{ij}\,k_j\right), \quad i = 1, \ldots, s, \\
                    y_1 &= y + h \sum_{i=1}^{s} b_i\,k_i.
                    \end{aligned}$$

                    <p>For example, the classical RK4 has the tableau:</p>

                    $$
                    \begin{array}{c|cccc}
                    0 \\
                    1/2 & 1/2 \\
                    1/2 & 0 & 1/2 \\
                    1 & 0 & 0 & 1 \\
                    \hline
                    & 1/6 & 1/3 & 1/3 & 1/6
                    \end{array}
                    $$

                    <p>When you Taylor-expand all $s$ stages and collect terms by powers
                        of $h$, each term in the expansion corresponds to a rooted tree.
                        The tree structure encodes exactly which stages feed into which: each
                        edge in the tree represents one level of $f$-evaluation nesting, and
                        branching at a node represents multiple arguments feeding into a
                        higher derivative of $f$.</p>


                    <h2>The trees return</h2>

                    <p>We now have two power series in $h$, one from each side, and both are
                        indexed by rooted trees. On the exact side, each tree $\tau$ with $|\tau|$
                        vertices contributes a coefficient $1/\gamma(\tau)$. On the Runge-Kutta
                        side, the same tree contributes a coefficient $\Phi(\tau)$ that depends on
                        the Butcher tableau entries.</p>

                    <p>An <strong>order condition</strong> is the requirement that these two match:</p>

                    $$
                    \Phi(\tau) = \frac{1}{\gamma(\tau)}.
                    $$

                    <p>The method has order $p$ if this holds for every tree with at most $p$ vertices.
                        Since the number of rooted trees with $n$ vertices is $1, 1, 2, 4, 9, 20, 48, \ldots$
                        (<a href="https://oeis.org/A000081" target="_blank">OEIS A000081</a>),
                        the total number of conditions grows as:</p>

                    <table style="margin: 1.5rem auto; border-collapse: collapse; font-size: 0.9rem;">
                        <thead>
                            <tr>
                                <th
                                    style="padding: 0.4rem 1rem; border-bottom: 2px solid var(--border-color); text-align: center;">
                                    Order $p$</th>
                                <th
                                    style="padding: 0.4rem 1rem; border-bottom: 2px solid var(--border-color); text-align: center;">
                                    New trees</th>
                                <th
                                    style="padding: 0.4rem 1rem; border-bottom: 2px solid var(--border-color); text-align: center;">
                                    Total conditions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    1</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    1</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    1</td>
                            </tr>
                            <tr>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    2</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    1</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    2</td>
                            </tr>
                            <tr>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    3</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    2</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    4</td>
                            </tr>
                            <tr>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    4</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    4</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    8</td>
                            </tr>
                            <tr>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    5</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    9</td>
                                <td
                                    style="padding: 0.4rem 1rem; text-align: center; border-bottom: 1px solid var(--border-color);">
                                    17</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.4rem 1rem; text-align: center;">6</td>
                                <td style="padding: 0.4rem 1rem; text-align: center;">20</td>
                                <td style="padding: 0.4rem 1rem; text-align: center;">37</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Computing $\Phi(\tau)$ and $\gamma(\tau)$</h3>

                    <p>Both $\Phi$ and $\gamma$ are defined recursively on the tree structure.
                        Write $c_i = \sum_j a_{ij}$ (the row sums of $A$).</p>

                    <p><strong>The density $\gamma(\tau)$</strong> comes from the exact side.
                        For a single leaf, $\gamma(\bullet) = 1$. For a tree $\tau = [\tau_1, \ldots, \tau_m]$
                        with $m$ children:</p>

                    $$
                    \gamma(\tau) = |\tau| \cdot \gamma(\tau_1) \cdots \gamma(\tau_m).
                    $$

                    <p><strong>The RK weight $\Phi(\tau)$</strong> is built by walking the tree bottom-up.
                        A leaf $\bullet$ at stage $i$ contributes $1$. A node with children
                        $\tau_1, \ldots, \tau_m$ at stage $i$ contributes the product
                        $\prod_k \Phi_i(\tau_k)$, where each child's weight is summed over stages via
                        $a_{ij}$. The final answer sums over stages via $b_i$.</p>

                    <p>Let's compute both for the trees through order 3:</p>

                    <table style="margin: 1.5rem auto; border-collapse: collapse; font-size: 0.86rem;">
                        <thead>
                            <tr>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Tree $\tau$</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    $F(\tau)$</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    $\gamma(\tau)$</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    $\Phi(\tau)$</th>
                                <th
                                    style="padding: 0.4rem 0.7rem; border-bottom: 2px solid var(--border-color); text-align: left;">
                                    Condition</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\bullet$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$f$
                                </td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$1$
                                </td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\sum_i b_i$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$\sum
                                    b_i = 1$</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $[\bullet]$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$f'f$
                                </td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$2
                                    \cdot 1 = 2$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\sum_i b_i c_i$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$\sum
                                    b_i c_i = \tfrac{1}{2}$</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $[\bullet,\bullet]$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $f''(f,f)$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$3
                                    \cdot 1 \cdot 1 = 3$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\sum_i b_i c_i^2$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$\sum
                                    b_i c_i^2 = \tfrac{1}{3}$</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $[[\bullet]]$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $f'f'f$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$3
                                    \cdot 2 = 6$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">
                                    $\sum_i b_i \sum_j a_{ij} c_j$</td>
                                <td style="padding: 0.4rem 0.7rem; border-bottom: 1px solid var(--border-color);">$\sum
                                    b_i (Ac)_i = \tfrac{1}{6}$</td>
                            </tr>
                        </tbody>
                    </table>

                    <p>Notice how the tree shape determines $\Phi$. The "bushy" tree $[\bullet,\bullet]$
                        has two leaves attached directly to the root, so each leaf contributes a factor
                        of $c_i$ (the row sum), giving $\Phi = \sum b_i c_i^2$. The "tall" tree $[[\bullet]]$
                        has a child which is itself $[\bullet]$, so we go one level deeper through the
                        $a_{ij}$: $\Phi = \sum_i b_i \sum_j a_{ij} c_j$.</p>

                    <p>The general rule is: <strong>branching in the tree becomes multiplication</strong>
                        (more children at a node means more factors of $c_i$),
                        and <strong>depth in the tree becomes summation over $a_{ij}$</strong>
                        (each additional level of nesting adds another layer of $\sum_j a_{ij}$).
                        The recursion mirrors the tree exactly.</p>


                    <h2>B-series</h2>

                    <p>The observation that both the exact solution and every Runge-Kutta
                        method can be written as a sum over rooted trees leads to a
                        powerful formalism called <em>B-series</em>, introduced by
                        Hairer and Wanner (1974).</p>

                    <p>A B-series is a (formal) power series indexed by
                        rooted trees:</p>

                    $$
                    B(a, y) = y + \sum_{\tau} \frac{h^{|\tau|}}{\sigma(\tau)}\,a(\tau)\,F(\tau)(y),
                    $$

                    <p>where $a$ is a function that assigns a real number to each tree.
                        $F(\tau)(y)$ is the elementary differential (the product of derivatives
                        of $f$ encoded by $\tau$). The coefficient $a(\tau)$ is the only part
                        that changes between the exact solution and a numerical method.</p>

                    <p>Specifically:</p>

                    <ul>
                        <li>The <strong>exact solution</strong> is a B-series with
                            $a(\tau) = 1/\gamma(\tau)$ for every tree.</li>
                        <li>Any <strong>Runge-Kutta method</strong> is also a B-series, with
                            $a(\tau) = \Phi(\tau)$ determined by the Butcher tableau.</li>
                    </ul>

                    <p>The order conditions become a clean, unified statement:</p>

                    <blockquote
                        style="border-left: 3px solid var(--accent-primary); padding-left: 1rem; margin: 1.5rem 0; color: var(--text-secondary); font-style: italic;">
                        A method has order $p$ &ensp;$\iff$&ensp;
                        $\Phi(\tau) = 1/\gamma(\tau)$ for all trees $\tau$ with $|\tau| \leq p$.
                    </blockquote>

                    <p>This is Butcher's fundamental theorem. It reduces a potentially
                        complicated analysis to a tree-by-tree check.</p>


                    <h2>The bigger picture</h2>

                    <p>We have now seen rooted trees appear in three different settings:</p>

                    <ol>
                        <li><strong>Faà di Bruno's formula</strong>
                            (<a href="/blog/2023/11/rooted-trees-and-differentiation/">part II</a>):
                            the $n$th derivative of a composed function $f(g(x))$ is a sum
                            over rooted trees.</li>
                        <li><strong>Hyper-dual numbers</strong>
                            (<a href="/blog/2026/02/hyper-dual-numbers/">part III</a>):
                            the labels on the infinitesimals are the tree labels, and
                            the algebra enforces the correct combinatorics.</li>
                        <li><strong>Runge-Kutta order conditions</strong> (this post):
                            a numerical ODE solver is accurate to order $p$ if and only
                            if it matches the exact tree coefficients up to trees of size $p$.</li>
                    </ol>

                    <p>The connection is not a coincidence. The Taylor expansion of the
                        exact ODE solution <em>is</em> a repeated application of the chain and
                        product rules (because $y'' = (f \circ y)' = f'(y)\,y' = f'(y)\,f(y)$,
                        and so on). The trees in the order conditions are the same trees
                        because they encode the same combinatorial structure: all the ways
                        derivatives of $f$ can be composed.</p>

                    <h3>B-series as linearisation</h3>

                    <p>The composition of two B-series is again a B-series, and the
                        composition operation defines a group — the <em>Butcher group</em>.
                        The exact flow $\varphi_h : y_0 \mapsto y(h)$ is a group element,
                        and so is any RK method $\Psi_h$. The relationship between them
                        is a group-theoretic one: the error $\Psi_h^{-1} \circ \varphi_h$
                        is itself a B-series.</p>

                    <p>Like any Lie group, the Butcher group has a <em>Lie algebra</em>:
                        the tangent space at the identity. Working with B-series
                        coefficients — the map $\tau \mapsto a(\tau)$ — is working in
                        this linearised setting. The B-series itself is the exponential
                        map from the Lie algebra to the group. In other words:</p>

                    <blockquote
                        style="border-left: 3px solid var(--accent-primary); padding-left: 1rem; margin: 1.5rem 0; color: var(--text-secondary); font-style: italic;">
                        A B-series is to the Butcher group what a Taylor series is to $\mathbb{R}$:
                        it is the local expansion of a group element near the identity.
                        Truncating at order $p$ is a $p$th-order linearisation of the flow.
                    </blockquote>

                    <p>This is why <strong>backward error analysis</strong> works so cleanly:
                        the logarithm of the RK flow in the Butcher group gives a modified
                        vector field $\tilde{f}$ such that $\Psi_h$ is the <em>exact</em> flow
                        of $y' = \tilde{f}(y)$. The logarithm is computable via the
                        Baker-Campbell-Hausdorff formula — which is, again, indexed by trees.</p>

                    <h3>Beyond smooth paths: signatures and rough paths</h3>

                    <p>Everything above assumes the driving signal is smooth: the ODE
                        $y' = f(y)$ is driven by time, which is as smooth as it gets.
                        But what if the driving signal is rough — like Brownian motion,
                        which is continuous but <em>nowhere differentiable</em>?</p>

                    <p>For a smooth path $X : [0,T] \to \mathbb{R}^d$, the iterated
                        integrals</p>

                    $$
                    \int_0^T \int_0^{t_1} \cdots \int_0^{t_{k-1}} dX^{i_1} \cdots dX^{i_k}
                    $$

                    <p>form the <em>signature</em> of $X$ (Chen, 1950s). The signature is
                        a kind of "noncommutative Taylor expansion" of the path: it captures
                        all the information you need to solve controlled differential equations
                        $dY = f(Y)\,dX$. Where B-series are indexed by <strong>rooted trees</strong>,
                        signatures are indexed by <strong>words</strong> (sequences of indices).</p>

                    <p>Terry Lyons' <em>rough path theory</em> (1998) shows that this
                        formalism extends to paths that are too irregular for classical
                        calculus. You don't need the path to be differentiable — you just
                        need to postulate enough iterated integrals as primitive data, and
                        the solution map becomes continuous. This puts Itô and Stratonovich
                        stochastic integration on the same footing as deterministic integration:
                        they correspond to different choices of the "second-level" iterated
                        integral of Brownian motion.</p>

                    <p>The algebraic structures are closely related. The shuffle product
                        on signatures and the Butcher product on trees are both instances
                        of Hopf algebra structures, and there is a morphism connecting them.
                        The decorated trees of B-series and the tensor words of signatures
                        are two faces of the same combinatorial coin.</p>

                    <h3>What about nowhere-continuous functions?</h3>

                    <p>The classical derivative requires continuity. But Schwartz's
                        <em>distribution theory</em> (1950s) extends differentiation to
                        <em>any</em> function — even nowhere-continuous ones — by defining
                        the derivative through duality: $\langle f', \varphi \rangle =
                        -\langle f, \varphi' \rangle$ for smooth test functions $\varphi$.
                        The "derivative" of a nowhere-continuous function is a distribution
                        that may not correspond to any classical function at all.
                    </p>

                    <p>This matters for stochastic PDEs, where solutions can be so rough that
                        you cannot even <em>multiply</em> them pointwise (a fundamental problem
                        since the product of two distributions is not always well-defined).
                        Martin Hairer's <em>regularity structures</em> (2014 Fields Medal)
                        solve this by building a local "Taylor expansion" of the solution
                        at each point, using <strong>decorated trees</strong> — the same trees
                        from B-series, extended to handle distributional objects. The
                        renormalization procedure that makes the products well-defined uses
                        the Connes-Kreimer Hopf algebra on these trees.</p>

                    <p>So the story comes full circle: it starts with the smoothest
                        possible setting (Taylor expansions of analytic functions), passes
                        through numerical ODE solvers, and arrives at the roughest possible
                        objects (stochastic PDEs with distributional solutions). The rooted
                        trees are the thread that runs through all of it.</p>


                    <h3>References</h3>

                    <ul style="font-size: 0.88rem; color: var(--text-secondary);">
                        <li>J.C. Butcher, <em>Coefficients for the study of Runge-Kutta integration processes</em>,
                            J. Austral. Math. Soc. 3, 185-201 (1963).</li>
                        <li>E. Hairer, S.P. Norsett, G. Wanner,
                            <em>Solving Ordinary Differential Equations I: Nonstiff Problems</em>,
                            Springer (1993). Chapter II.
                        </li>
                        <li>T.J. Lyons, <em>Differential equations driven by rough signals</em>,
                            Rev. Mat. Iberoam. 14(2), 215-310 (1998).</li>
                        <li>M. Hairer, <em>A theory of regularity structures</em>,
                            Invent. Math. 198(2), 269-504 (2014).</li>
                        <li>A. Connes, D. Kreimer, <em>Hopf algebras, renormalization and
                                noncommutative geometry</em>, Comm. Math. Phys. 199, 203-242 (1998).</li>
                        <li>Ch. Brouder, <em>Runge-Kutta methods and renormalization</em>,
                            Eur. Phys. J. C 12, 521-534 (2000).</li>
                    </ul>

                </div>
            </article>

        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer__links">
                <a href="https://scholar.google.com/citations?user=613GPbQAAAAJ&hl=en" target="_blank">Google
                    Scholar</a>
                <a href="https://github.com/danielewworrall" target="_blank">GitHub</a>
                <a href="https://twitter.com/danielewworrall" target="_blank">Twitter</a>
                <a href="https://www.linkedin.com/in/daniel-worrall-46a43238/" target="_blank">LinkedIn</a>
            </div>
            <p class="footer__text">&copy; 2026 Daniel Worrall</p>
        </div>
    </footer>

    <script src="/script.js"></script>
</body>

</html>